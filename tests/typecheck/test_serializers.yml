-   case: multiple_inheritance_from_two_serializers_with_meta_nested_class_defined
    main: |
        from rest_framework import serializers
        class SerializerA(serializers.Serializer):
            class Meta:
                pass
        class SerializerB(serializers.Serializer):
            class Meta:
                pass
        class SerializerC(SerializerA, SerializerB):
            pass

- case: model_serializer_meta_attributes
  main: |
    from rest_framework import serializers

    reveal_type(serializers.ModelSerializer.Meta.model) # N: Revealed type is "Type[_MT?]"
    reveal_type(serializers.ModelSerializer.Meta.fields) # N: Revealed type is "typing.Sequence[builtins.str]"
    reveal_type(serializers.ModelSerializer.Meta.read_only_fields) # N: Revealed type is "Union[typing.Sequence[builtins.str], None]"
    reveal_type(serializers.ModelSerializer.Meta.exclude) # N: Revealed type is "Union[typing.Sequence[builtins.str], None]"
    reveal_type(serializers.ModelSerializer.Meta.depth) # N: Revealed type is "Union[builtins.int, None]"
    reveal_type(serializers.ModelSerializer.Meta.extra_kwargs) # N: Revealed type is "builtins.dict[builtins.str, builtins.dict[builtins.str, Any]]"

- case: test_model_serializer_passes_check
  main: |
    from rest_framework import serializers
    from django.contrib.auth.models import User
    from typing import Type

    class TestSerializer(serializers.ModelSerializer):
        class Meta:
          model = User

    def is_meta_model(serializer: Type[serializers.ModelSerializer]) -> bool:
        return bool(serializer.Meta.model)

    reveal_type(is_meta_model(TestSerializer)) # N: Revealed type is "builtins.bool"

- case: test_model_serializer_with_customized_serializer_field_mapping
  main: |
    from rest_framework import serializers
    from django.contrib.auth.models import User

    class TestSerializer(serializers.ModelSerializer):
        serializer_related_field = serializers.PrimaryKeyRelatedField
        serializer_related_to_field = serializers.SlugRelatedField
        serializer_url_field = serializers.HyperlinkedIdentityField
        serializer_choice_field = serializers.ChoiceField

        class Meta:
            model = User

- case: test_hyperlinked_model_serializer_with_customized_serializer_field_mapping
  main: |
    from rest_framework import serializers
    from django.contrib.auth.models import User

    class TestSerializer(serializers.HyperlinkedModelSerializer):
        serializer_related_field = serializers.HyperlinkedRelatedField

        class Meta:
            model = User

- case: test_model_serializer_with_overriden_fields_property
  main: |
    from rest_framework import serializers
    from rest_framework.utils.serializer_helpers import BindingDict
    from django.contrib.auth.models import User
    from django.utils.functional import cached_property

    class TestSerializer(serializers.ModelSerializer):
        class Meta:
            model = User

        @cached_property
        def fields(self) -> BindingDict:
            return super().fields

- case: test_base_serializer_with_raise_exception_true
  main: |
    from rest_framework.viewsets import GenericViewSet
    from rest_framework.request import Request
    from rest_framework.response import Response
    from rest_framework import serializers

    class MySerializer(serializers.BaseSerializer):
        pass

    class MyView(generics.GenericViewSet):
        serializer_class = MySerializer

        def action(self, request: Request) -> Response:
            serializer = self.serializer_class(request.data)
            if serializer.is_valid(raise_exception=True):
                return Response(status=200, data={})
